<!-- Live Plot Component (Quick Collect)-->
<!-- Author: Evan Larkin-->
<!-- Date: March 2021-->
<script type="text/javascript">
  // Data from the collection 8 x N
  var data = [[], [], [], [], [], [], [], []];
  // Labels required for the plot (x-axis). Equal to the data point number of the recording.
  var labels = [];
  // Data that will be used to calculate the feature. Reset every interval
  var featuredata = [];
  // Time (ms) between data fetches and plot update
  var FRAME_SIZE = 100;

  // Configuration of the chart (ChartJS: https://www.chartjs.org/)
  var chartConfig = {
    type: "line",
    data: {
      labels: new Array(500).fill(0),
      datasets: [
        {
          data: [],
          pointRadius: 0,
          borderWidth: 1,
          borderColor: "black",
          fill: false,
        },
      ],
    },
    options: {
      animation: {
        duration: 0, // general animation time
      },
      elements: {
        line: {
          tension: 0, // disables bezier curves
        },
      },
      hover: {
        animationDuration: 0, // duration of animations when hovering an item
      },
      legend: {
        display: false,
      },
      tooltip: {
        enabled: false,
      },
      layout: {
        padding: {
          left: 0,
          right: 10,
          top: 15,
          bottom: 0,
        },
      },
      responsiveAnimationDuration: 0, // animation duration after a resize
      scales: {
        xAxes: [
          {
            display: false,
          },
        ],
        yAxes: [
          {
            display: true,
            scaleLabel: {
              display: true,
            },
            ticks: {
              suggestedMin: -0.08,
              suggestedMax: 0.08,
            },
          },
        ],
      },
    },
  };
  // Apply charts to all the HTML below
  ctx1 = document.getElementById("liveChart1");
  ctx2 = document.getElementById("liveChart2");
  ctx3 = document.getElementById("liveChart3");
  ctx4 = document.getElementById("liveChart4");
  ctx5 = document.getElementById("liveChart5");
  ctx6 = document.getElementById("liveChart6");
  ctx7 = document.getElementById("liveChart7");
  ctx8 = document.getElementById("liveChart8");
  var myLineChart1 = new Chart(ctx1, chartConfig);
  var myLineChart2 = new Chart(ctx2, chartConfig);
  var myLineChart3 = new Chart(ctx3, chartConfig);
  var myLineChart4 = new Chart(ctx4, chartConfig);
  var myLineChart5 = new Chart(ctx5, chartConfig);
  var myLineChart6 = new Chart(ctx6, chartConfig);
  var myLineChart7 = new Chart(ctx7, chartConfig);
  var myLineChart8 = new Chart(ctx8, chartConfig);
  // Hide plots 2-8 until selected by user
  for (var z = 2; z <= 8; z++)
    $(`#plotChannel${z}`).attr("style", "display:none");

  /* 
    On data collection start
  */
  function onStart() {
    // Which channels are active (selected by the user)
    let channels = 0;
    let channelsActive = new Array(8).fill(false);
    $('[id^="qc-channel-"]').each(function (i, el) {
      if ($(this).attr("active") == "true") {
        channels++;
        channelsActive[i] = true;
      }
    });

    // Determine the reader selected
    let reader = $("#daq-select").val();
    console.log($("#input-type-daq").is(":checked"));
    if ($("#input-type-daq").is(":checked")) reader = $("#daq-select").val();
    if ($("#input-type-file").is(":checked")) reader = "file";

    /* 
      This function is an accurate interval function, accounting for drift
      Args: workFunc(function): a function that is called on every interval
            interval(int): interval time (ms)
            errorFunc(function): called when an error occurs during execution
    */
    function AdjustingInterval(workFunc, interval, errorFunc) {
      var that = this;
      var expected, timeout;
      this.interval = interval;

      this.start = function () {
        expected = Date.now() + this.interval;
        timeout = setTimeout(step, this.interval);
      };

      this.stop = function () {
        clearTimeout(timeout);
      };

      function step() {
        var drift = Date.now() - expected;
        if (drift > that.interval) {
          // You could have some default stuff here too...
          if (errorFunc) errorFunc();
        }
        workFunc();
        expected += that.interval;
        timeout = setTimeout(step, Math.max(0, that.interval - drift));
      }
    }

    var ticker = null;

    // On collection stop
    $("#stopBtn").click(function () {
      if (ticker != null) {
        fetch(`http://127.0.0.1:5000/stop/${reader}`)
          .then((response) => response.json)
          .then((result) => {
            if (!result) showToast("Error stopping reader");
          });
        ticker.stop();
      }
    });

    // Do work initialization
    var i = 0;
    var frame = 0;
    const featureFrame = ($("#time-step").val() * 1000) / FRAME_SIZE;

    /* 
      This function is passed to the interval function, ran every x ms
    */
    function doWork() {
      fetch(`http://127.0.0.1:5000/read/${reader}`)
        .then((response) => response.json())
        .then((result) => {
          // Time to log the selected feature
          if (frame % featureFrame == 0) {
            onNewFeatureData(featuredata);
            featuredata = [];
          }

          //Format the data for plotting
          try {
            if (data.length && result[0].length) {
              for (var n = 0; n < result[0].length; n++) {
                labels.push(i);
                if (labels.length > 1000) {
                  labels.shift();
                }
                channelsActive.map((channelActive, channelInd) => {
                  if (channelActive) {
                    //console.log(data[channelInd].length,channelInd)
                    if (data[channelInd].length > 1000) {
                      data[channelInd].shift();
                    }

                    data[channelInd].push({ x: i, y: result[channelInd][n] });
                    featuredata.push(result[channelInd][n]);
                  }
                });
                i++;
              }
            }
          } catch (e) {
            console.log(e);
            console.log(result);
            console.log(data);
          }

          // Update the plot data for all active channels
          if (channelsActive[0]) {
            myLineChart1.data.datasets[0].data = data[0];
            myLineChart1.data.labels = labels;
            myLineChart1.update();
          }
          if (channelsActive[1]) {
            myLineChart2.data.datasets[0].data = data[1];
            myLineChart2.data.labels = labels;
            myLineChart2.update();
          }
          if (channelsActive[2]) {
            myLineChart3.data.datasets[0].data = data[2];
            myLineChart3.data.labels = labels;
            myLineChart3.update();
          }
          if (channelsActive[3]) {
            myLineChart4.data.datasets[0].data = data[3];
            myLineChart4.data.labels = labels;
            myLineChart4.update();
          }
          if (channelsActive[4]) {
            myLineChart5.data.datasets[0].data = data[4];
            myLineChart5.data.labels = labels;
            myLineChart5.update();
          }
          if (channelsActive[5]) {
            myLineChart6.data.datasets[0].data = data[5];
            myLineChart6.data.labels = labels;
            myLineChart6.update();
          }
          if (channelsActive[6]) {
            myLineChart7.data.datasets[0].data = data[6];
            myLineChart7.data.labels = labels;
            myLineChart7.update();
          }
          if (channelsActive[7]) {
            myLineChart8.data.datasets[0].data = data[7];
            myLineChart8.data.labels = labels;
            myLineChart8.update();
          }

          frame++;
        })
        .catch((e) => {
          console.log("ERRO", e);
          showToast("Read Error");
          ticker.stop();
        });
    }

    // Start the reader to prepare for collection
    fetch(`http://127.0.0.1:5000/start/${reader}`)
      .then((response) => response.json())
      .then((result) => {
        console.log("start CALL", result);
        if (result == false) showToast("Error Starting Reader");
        else {
          ticker = new AdjustingInterval(doWork, FRAME_SIZE);
          ticker.start();
        }
      });
  }
</script>

<div>
  <div id="plotChannel1">
    <h6>Channel 1</h6>
    <canvas id="liveChart1"></canvas>
  </div>
  <div id="plotChannel2">
    <h6>Channel 2</h6>
    <canvas id="liveChart2"></canvas>
  </div>
  <div id="plotChannel3">
    <h6>Channel 3</h6>
    <canvas id="liveChart3"></canvas>
  </div>
  <div id="plotChannel4">
    <h6>Channel 4</h6>
    <canvas id="liveChart4"></canvas>
  </div>
  <div id="plotChannel5">
    <h6>Channel 5</h6>
    <canvas id="liveChart5"></canvas>
  </div>
  <div id="plotChannel6">
    <h6>Channel 6</h6>
    <canvas id="liveChart6"></canvas>
  </div>
  <div id="plotChannel7">
    <h6>Channel 7</h6>
    <canvas id="liveChart7"></canvas>
  </div>
  <div id="plotChannel8">
    <h6>Channel 8</h6>
    <canvas id="liveChart8"></canvas>
  </div>
</div>
